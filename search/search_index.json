{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#sciquill","title":"Sciquill","text":"<p>NOTE! Sciquill is currently fully functional and I've been using it for years to build all kinds of documents, from grants to manuscripts to NIH biosketches and more. However, it's under constant development and I haven't had time to document everything, as this is a side project. So, this documentation is provided as a work in progress. If you are interested in using or contributing to this system, please contact me and I'm happy to update things as needed.</p>"},{"location":"#motivation","title":"Motivation","text":"<p>Sciquill is an academic publishing system. It helps to author academic documents using <code>markdown</code> and <code>YAML</code>. Document types include grants, papers, biosketches, CVs, dissertations, letters... anything you might want to write in <code>markdown</code>, really. Sciquill is more of a publishing philosophy than a piece of software. It contains some scripts to glue together various stages of the authoring pipeline, but primarily it relies on existing tools, notably, pandoc, inkscape, and markmeld. It provides templates, styles, workflows, and scripts that make it simple to go from markdown text and structured YAML data to beautiful PDF or other outputs, all from inside GitHub or your local computer. Sciquill brings us closer to the goal of authoring all types of scientific documents in markdown to completely separate content from style.</p>"},{"location":"#the-sciquill-workflow","title":"The sciquill workflow","text":"<p>You specify 3 pieces of information: content, structure, and style. You use these to generate your desired output. So the sciquill workflow can be summarized as: <code>content + structure + style -&gt; output</code>.</p>"},{"location":"#1-content","title":"1. Content","text":"<p>Write your content (e.g. manuscript, CV, grant) in <code>markdown</code> and/or <code>YAML</code> format. For editing and collaborating on your source content, you have 3 options: 1) local text editor of your choice; 2) collaborative markdown editor (e.g. hedgedoc or hackmd); or 3. a GitHub repository.</p>"},{"location":"#2-structure","title":"2. Structure","text":"<p>The structure of your output is how your content comes together and is formatted. All of your input <code>YAML</code> content plus your <code>markdown</code> content is integrated using a <code>jinja</code> template. Sciquill collates your inputs and renders your jinja template using markmeld. The output is whatever you specify with your jinja template, but frequently, it will produce <code>markdown</code> output that integrates your inputs.</p>"},{"location":"#3-style","title":"3. Style","text":"<p>The styles are the structure and \"look and feel\" of your output. Are you building a web page? A PDF document? For this, we rely on pandoc. You specify the style using a pandoc template, and we simply pipe the output of <code>markmeld</code> into <code>pandoc</code> to generate the final output.</p>"},{"location":"#connecting-content-structure-and-style","title":"Connecting content, structure, and style","text":"<p>Configure markmeld by specifying the content, structure, and style in a <code>YAML</code> configuration file, <code>_markmeld.yaml</code>.</p>"},{"location":"#quick-start","title":"Quick start","text":""},{"location":"#use-github-actions","title":"Use GitHub Actions","text":"<p>The easiest way to get started with sciquill is using GitHub actions. We have several demo repositories that are pre-configured to build different media types with GitHub actions, so you literally need only fork the repo and then edit the source markdown files to trigger a build of your own document. Then, you can just change the configuration options to switch the template or other settings as needed. This way, you can start building PDFs without downloading or installing anything.</p> <p>If you want more control, or to iterate more quickly, you can also download sciquill and build documents locally. More details in installation instructions.</p> <p>You trigger a particular build using pre-defined makefile. Assuming prerequisites are installed, you invoke sciquill locally like this:</p> <pre><code>git clone git@github.com:databio/sciquill.git\ncd sciquill/examples/manuscript\nmake\n</code></pre> <p>This use of <code>make</code> is not to build sciquill; this is what you'd actually use to build your PDF output.</p>"},{"location":"markmeld/","title":"Introduction","text":""},{"location":"markmeld/#introduction","title":"Introduction","text":"<p>Markmeld is a markdown melder. It merges <code>yaml</code> and <code>markdown</code> content using <code>jinja2</code> templates. You configure markmeld with your content in computer-readable <code>.md</code> and <code>.yaml</code> files, and markmeld helps produce polished, publication-ready versions of your content. Markmeld is useful for many types of output document, including resumes, biosketches, manuscripts, proposals, books, and more. </p>"},{"location":"markmeld/#how-it-works","title":"How it works","text":"<ol> <li>Store your content in computer-readable formats: <code>.md</code> for unstructured text, <code>.yaml</code> format for structured content like lists or objects. </li> <li>Write or find a jinja template that produces the output document you are trying to create. We have a variety of common examples in a public repository.</li> <li>Configure markmeld with a <code>yaml</code> configuration file to point to 1) your content files; and 2) your jinja template.</li> </ol> <p>Markmeld is useful independently, but is particularly powerful when combined with pandoc -- you pipe the markmeld output in markdown format to pandoc, making it easy to format the output in a variety of downstream output types, such as HTML or PDF via LaTeX. This lets you design design powerful multi-file documents, restructured into different output formats.</p> <p></p>"},{"location":"markmeld/#why-is-this-better-than-just-stringing-inputs-together-with-pandoc","title":"Why is this better than just stringing inputs together with pandoc?","text":"<p>For simple use cases, you can use pandoc without markmeld. You just provide a list of markdown files, which pandoc concatenates. This works for very basic documents that do nothing more than string together a list of markdown files. Markmeld adds power to this approach by providing several benefits:</p> <ol> <li> <p>Structured content. Most importantly, markmeld integrates structured yaml data. While pandoc alone can easily concatenate prose content (in markdown format), markmeld allow you to also integrate structured content (in yaml format) into one output. This is useful for something like a CV, where I have both prose components and lists, which I'd rather draw from a structured YAML file.</p> </li> <li> <p>Templated output. Markmeld's jinja template gives you more control over the structure of the output. Vanilla pandoc can only concatenate <code>md</code> inputs in a sequence. Jinja templates let you re-arrange, subset, merge, and even compute on the input, allowing you to create arbitrarily complex output. For simple documents that don't need structured content, you can get by with concatenating <code>.md</code> files with vanilla pandoc. But even in these situations, you gain something from going the route of the jinja template with markmeld: it formalizes the linking of documents into a separate file, instead of relying the on order and content of CLI arguments to pandoc. So you can more easily write a little recipe saying, \"provide these pieces of content under these names, and then use this jinja template to produce the output\". Markmeld makes that recipe reproducible.</p> </li> <li> <p>Flexible downstream uses. Markmeld outputs are not restricted to markdown, but could directly produce whatever you design with your jinja template. For example, you could use markmeld to restructure data into a JSON output to pipe into some other downstream system.</p> </li> <li> <p>Pre-build hooks. Markmeld can also incorporate non-file-producing commands. You can also build \"meta-targets\", which are targets made up of other targets, so a single command can build multiple outputs. Markmeld replaces the need for a script or Makefile that runs prepwork, like updating a bibtex database.</p> </li> <li> <p>Mail merge. Markmeld provides loop functions that allow you to generate multiple similar documents that differ based on structured input content, like a traditional mail merge.</p> </li> <li> <p>Target factories. Markmeld provides a plugin system that allows you to auto-create targets using your own Python code.</p> </li> </ol> <p>Plus, there's more! Read on to see if Markmeld can help solve some of your content management issues.</p>"},{"location":"markmeld/changelog/","title":"Changelog","text":""},{"location":"markmeld/changelog/#040-unreleased","title":"[0.4.0] -- Unreleased","text":"<ul> <li>Add more informative error message when remote jinja template is not found</li> <li>Allow commands with braces that are not variables without crashing.</li> </ul>"},{"location":"markmeld/changelog/#030-2023-11-06","title":"[0.3.0] -- 2023-11-06","text":"<ul> <li>Revamped the <code>_md</code> and <code>_array</code> variables to be dicts, with <code>ext</code>, <code>content</code>, <code>frontmatter</code>, and <code>path</code> properties.</li> <li>Added in ability to specify abstract targets, which don't show up in buildable lists, issue 19</li> <li>mm now raises an error if you try to inherit from an non-existing target, issue 20</li> <li>Overriding targets is no longer allowed, issue 22</li> <li>Major revamps on data structures available to jinja template</li> <li>Add <code>-t</code> flag to view template for a target</li> <li>Allow glob factory to use <code>inherit_from</code>.</li> <li>Improve user messages to guide when there are problems</li> </ul>"},{"location":"markmeld/changelog/#020-2023-01-07","title":"[0.2.0] -- 2023-01-07","text":"<ul> <li>Added <code>-e</code> flag to explain a target</li> <li>Add <code>-i</code> flag to initialize an empty <code>_markmeld.yaml</code> file</li> <li>Fixed bugs with importing</li> <li>Fixed bug with prebuilds</li> <li>Allow opening files on MacOS</li> <li>Enabled using environment variables in variables</li> <li>Sort targets</li> <li>Enable multiple inheritance</li> <li>Enable recursive imports</li> </ul>"},{"location":"markmeld/changelog/#010-2022-11-21","title":"[0.1.0] -- 2022-11-21","text":""},{"location":"markmeld/changelog/#changed","title":"Changed","text":"<ul> <li>Removed support for original beta config version</li> <li>Implemented base targets instead of inheriting from root config</li> <li>Completed refactoring and various bugfixes and tests</li> </ul>"},{"location":"markmeld/changelog/#002-2022-11-18","title":"[0.0.2] -- 2022-11-18","text":"<ul> <li>Transitional release that can handle both original beta and version 1 config formats.</li> </ul>"},{"location":"markmeld/commands/","title":"Alternative commands","text":"<p>The way markmeld works is that it uses your <code>jinja</code> template to integrate the content provided in a target's <code>data</code> section, and then it will pass the output of rendered template as <code>stdin</code> to an arbitrary command, which is specified in the target's <code>command</code> attribute. Typically, the rendered jinja template will produce markdown output, which we may call melded output, and markmeld then passes this to pandoc to convert to the final output to whatever output form, since markdown is the native input to pandoc. Because this use case is so common, markmeld has a default <code>command</code> attribute, which is this:</p> <pre><code>    command: pandoc --template \"{latex_template}\" --output \"{output_file}\"\n</code></pre> <p>If the intent of the target is to pass the rendered template output to pandoc like this, then you can simply omit the <code>command</code> and this will suffice for many targets. But, markmeld is really more flexible than this, and you can tweak it to do other things if you like. For example, you may not want to pass the input the pandoc. You may not even produce markdown from your jinja template. Or, you might want to run a different command, or not run a command at all. You can do all of this with markmeld. Here, we'll cover alternative commands, raw targets, and meta targets.</p>"},{"location":"markmeld/commands/#alternative-commands-targets-without-pandoc","title":"Alternative commands: targets without pandoc","text":"<p>Sometimes, the melded output is not markdown, and is my end product directly. For example, I may want to produce a <code>csv</code> file representation of some data I had in yaml format. Markmeld can also do this. In this case, you would just change the <code>command</code>, and don't use pandoc.</p> <pre><code>command: |\n  cat &gt; {output_file}\n</code></pre> <p>Then, your jinja template would spit out a csv file. This command basically just writes that to an output file. You can use it to get the output from jinja directly.</p>"},{"location":"markmeld/commands/#output-less-targets","title":"Output-less targets","text":""},{"location":"markmeld/commands/#raw-targets","title":"Raw targets","text":"<p>In typical targets, the melded output is passed to the command (usually pandoc) on <code>stdin</code>. But, you may just want to execute some command, and not pass anything to it on <code>stdin</code>. This type of a target is called a \"raw\" target, and you specify it with <code>type: raw</code>. Then, the command will run directly, and not pass the template render as stdin.</p> <pre><code>targets:\n  target_without_output:\n    type: raw\n    command: |\n      ...\n</code></pre>"},{"location":"markmeld/commands/#meta-targets","title":"Meta targets","text":"<p>Another type of target is called a meta target, which is a target that runs no command at all. Use <code>type: meta</code> to flag a target as a meta target. Meta targets are useful for creating a single target that just runs a bunch of other targets, for example.</p> <p>For example, <code>target1</code> is a meta target that just builds target2 and target3, then runs no other command:</p> <pre><code>targets:\n  target1:\n    type: meta\n    prebuild:\n      - target2\n      - target3\n</code></pre>"},{"location":"markmeld/commands/#abstract-targets","title":"Abstract targets","text":"<p>Another type of target is an abstract target, which is a target that can be imported, but not built. Abstract targets can also be <code>meta</code> or <code>raw</code> targets, so we don't specify them with <code>type</code>, but with <code>abstract: true</code>.</p> <p>For example, <code>base_target</code> below is an abstract target that can be used as a template for other concrete targets. You can use abstract targets to set up re-usable parameter sets or other configurations that you can then inheret in other targets.</p> <pre><code>targets:\n  targbase_target:\n    abstract: true\n    bibfolder: /path/to/bib/\n</code></pre>"},{"location":"markmeld/config_specification/","title":"Configuration specification","text":"<p>This document explains how to configure markmeld.</p> <p>A markmeld project is configured using a yaml configuration file, by default named <code>_markmeld.yaml</code>. This file specifies the things you want markmeld to build, which are called targets. Each target will include the data/content, the relevant templates, and anything else you want to include. Let's start with some quick definitions:</p>"},{"location":"markmeld/config_specification/#root-configuration","title":"Root configuration","text":"<p>The configurable attributes are:</p> <ul> <li><code>version</code>: Should be \"1\" for the version 1 of the markmeld configuration specification.</li> <li><code>targets</code>: a list of targets that can be built (described below)</li> <li><code>target_factories</code>: a list of target factories (see target factories)</li> <li><code>imports</code>: A list of markmeld configuration files imported by the current file (see imports)</li> <li><code>imports_relative</code>: Exactly like <code>imports</code>, but the imported targets will be built relative to the importing file (see imports)</li> </ul>"},{"location":"markmeld/config_specification/#the-targets-block","title":"The targets block","text":"<p>The configuration file must define a <code>targets</code> block. In this example, <code>targets</code> is the only top-level attribute. This block contains a series of named targets. In this example configuration file, <code>target1</code> is the only target defined. Let's look deeper at the variables that define individual targets. </p>"},{"location":"markmeld/config_specification/#target-configuration","title":"Target configuration","text":"<p>Under <code>target1</code>, we specify all the attributes of this target.</p> <ul> <li>custom variables: You can define variables, which are then available for your command. In this example, the command uses <code>{output_file}</code> and <code>{latex_template}</code>, which are defined as variables under the target. This attributes are made available to the build system, but not to the jinja templates.</li> <li><code>jinja_template</code>: The <code>jinja_template</code> is a special variable that specifies the path to the jinja template that markmeld will use to render the output. The path is relative to the config file where it is defined (see writing jinja templates).</li> <li><code>command</code>: The <code>command</code> attribute here is a special variable. It's the shell command to execute to build the target. The output of markmeld will be piped to this command on <code>stdin</code>. listed here turns out to be markmeld's default command, so in this case it could be omitted (see commands).</li> <li><code>type</code>: Specifies the type of target (see commands).</li> <li><code>data</code>: Finally, there's the <code>data</code> block, which is where the input content is specified. This is the main section that points to the content. This block includes several sub-attributes:<ul> <li><code>md_files</code>: a named list of markdown files, which will be made available to the templates</li> <li><code>md_globs</code>: Globs, where each file will be read, and available at the key of the filename.</li> <li><code>yaml_files</code>: a keyed list of yaml files to make available to the templates, under specified keys (to specify unkeyed files, use <code>yaml_globs_unkeyed</code>)</li> <li><code>yaml_globs</code>: a list of globs (regexes) to yaml files, which will be keyed by filename</li> <li><code>yaml_globs_unkeyed</code>: a list of globs (regexes) to yaml files, which will be directly available</li> <li><code>variables</code>: direct yaml data made available to the templates.</li> </ul> </li> <li><code>inherit_from</code>: Defines a base target; any base attributes will be available to the current target, with the local target taking priority in case of conflict (see inheriting)</li> <li><code>loop</code>: used to specify a <code>multi-output</code> target (see Multi-output targets)</li> <li><code>prebuild</code>: A list of other targets to build before the current target is built (see side targets).</li> <li><code>recursive_render</code>: Defaults to true, but you can turn off if you want to NOT recursively render (see recursive rendering).</li> </ul>"},{"location":"markmeld/google_drive_processor/","title":"Google Drive Processor","text":"<p>A unified Python class for processing Google Drive files, including downloading Google Docs as markdown and converting SVG files to PDFs.</p>"},{"location":"markmeld/google_drive_processor/#requirements","title":"Requirements","text":"<pre><code>pip install google-auth google-auth-oauthlib google-auth-httplib2 google-api-python-client python-frontmatter\n\n# For SVG to PDF conversion\nsudo apt-get install inkscape  # Ubuntu/Debian\nbrew install inkscape          # macOS\n</code></pre>"},{"location":"markmeld/google_drive_processor/#setup","title":"Setup","text":"<ol> <li>Create a service account in Google Cloud Console</li> <li>Download the service account credentials JSON file</li> <li>Place credentials in a secure location (default: <code>/home/nsheff/auth/shefflab-google-service-acct-credentials.json</code>)</li> <li>Share the Google Drive files/folders you want to access with the service account email</li> </ol>"},{"location":"markmeld/google_drive_processor/#quick-start","title":"Quick Start","text":"<pre><code>from markmeld.google_drive import GoogleDriveProcessor\n\n# Initialize processor\nprocessor = GoogleDriveProcessor()\n\n# Download and clean a Google Doc\ndoc = processor.download_doc('your-doc-id')\nprint(doc.content)  # Clean markdown content\n\n# Process SVG files from a folder\nresults = processor.process_svg_folder('folder-id')\n\n# Process entire manuscript folder (docs + figures)\nresults = processor.process_drive_folder('folder-id')\n</code></pre>"},{"location":"markmeld/google_drive_processor/#features","title":"Features","text":""},{"location":"markmeld/google_drive_processor/#document-processing","title":"Document Processing","text":"<ul> <li>Clean markdown output: Automatically removes escape characters, embedded images, and bold from headings</li> <li>File output: Save documents directly to disk</li> <li>Batch downloads: Process multiple documents at once</li> <li>Smart naming: Use Google Drive document names for files</li> <li>Flexible cleaning: Choose which cleaning operations to apply</li> <li>Metadata access: Get document information without downloading content</li> <li>Frontmatter parsing: Automatic YAML frontmatter detection and parsing</li> </ul>"},{"location":"markmeld/google_drive_processor/#svg-processing","title":"SVG Processing","text":"<ul> <li>SVG to PDF conversion: Convert SVG files to PDFs using Inkscape</li> <li>Batch processing: Process entire folders of SVG files</li> <li>Smart caching: Skip unchanged files using MD5 checksums</li> <li>Directory organization: Automatic output directory structure</li> </ul>"},{"location":"markmeld/google_drive_processor/#unified-processing","title":"Unified Processing","text":"<ul> <li>Manuscript folders: Process complete manuscript projects with documents and figures</li> <li>Auto-detection: Automatically finds manuscript documents and figure folders</li> </ul>"},{"location":"markmeld/google_drive_processor/#usage-examples","title":"Usage Examples","text":""},{"location":"markmeld/google_drive_processor/#basic-document-download","title":"Basic Document Download","text":"<pre><code># Download and clean with frontmatter parsing\ndoc = processor.download_doc('doc-id')\n\n# Download without cleaning\nraw = processor.download_doc_raw('doc-id')\n\n# Download cleaned markdown as string\ncontent = processor.download_doc_clean('doc-id')\n</code></pre>"},{"location":"markmeld/google_drive_processor/#save-documents-to-file","title":"Save Documents to File","text":"<pre><code># Download and save to specific file\nprocessor.download_doc('doc-id', output_path='output/document.md')\n\n# Download with selective cleaning\ncontent = processor.clean_markdown(\n    markdown_content,\n    clean_escapes=True,\n    remove_images=True,\n    strip_heading_bold=False  # Keep bold in headings\n)\n</code></pre>"},{"location":"markmeld/google_drive_processor/#process-svg-files","title":"Process SVG Files","text":"<pre><code># Process all SVGs in a folder\nresults = processor.process_svg_folder('folder-id')\nprint(f\"Converted: {results['stats']['converted']}\")\nprint(f\"Skipped: {results['stats']['skipped']}\")\n\n# Process without caching (always convert)\nresults = processor.process_svg_folder('folder-id', skip_unchanged=False)\n\n# List SVG files in a folder\nsvg_files = processor.list_svg_files('folder-id')\nfor svg in svg_files:\n    print(f\"{svg['name']}: {svg['id']}\")\n</code></pre>"},{"location":"markmeld/google_drive_processor/#batch-document-download","title":"Batch Document Download","text":"<pre><code># Download multiple docs to a folder\ndoc_ids = ['id1', 'id2', 'id3']\nresults = processor.download_docs_batch(\n    doc_ids,\n    output_folder='output/docs',\n    use_document_names=True  # Use Google Drive names\n)\n\n# Use convenience method\nresults = processor.process_docs(doc_ids)\n</code></pre>"},{"location":"markmeld/google_drive_processor/#custom-configuration","title":"Custom Configuration","text":"<pre><code># Use custom credentials and base directory\nprocessor = GoogleDriveProcessor(\n    credentials_path='/path/to/credentials.json',\n    local_base_dir='my_output',\n    scopes=['https://www.googleapis.com/auth/drive.readonly']\n)\n\n# Check processor configuration\nprint(processor)  # Simple string representation\nprint(repr(processor))  # Detailed representation\ninfo = processor.info()  # Get full configuration details\n</code></pre>"},{"location":"markmeld/google_drive_processor/#get-file-metadata","title":"Get File Metadata","text":"<pre><code># Get metadata for any file (doc, SVG, etc.)\nmetadata = processor.get_metadata('file-id')\nprint(f\"File: {metadata['name']}\")\nprint(f\"Type: {metadata['mimeType']}\")\nprint(f\"Modified: {metadata['modifiedTime']}\")\n</code></pre>"},{"location":"markmeld/google_drive_processor/#process-complete-manuscript-folder","title":"Process Complete Manuscript Folder","text":"<pre><code># Process a folder containing manuscript and figures\nresults = processor.process_drive_folder(\n    'folder-id',\n    process_doc=True,   # Download and clean manuscript\n    process_figs=True,  # Convert SVGs to PDFs\n    output_path='output/manuscript.md'\n)\n\n# Access results\nif results['document']:\n    print(f\"Processed: {results['document_name']}\")\nif results['figs_results']:\n    stats = results['figs_results']['stats']\n    print(f\"Figures: {stats['converted']} converted\")\n</code></pre>"},{"location":"markmeld/google_drive_processor/#api-reference","title":"API Reference","text":""},{"location":"markmeld/google_drive_processor/#initialization","title":"Initialization","text":"<pre><code>GoogleDriveProcessor(\n    credentials_path: Optional[str] = None,\n    local_base_dir: str = \"output\",\n    scopes: Optional[List[str]] = None\n)\n</code></pre>"},{"location":"markmeld/google_drive_processor/#document-methods","title":"Document Methods","text":"<ul> <li><code>download_doc(doc_id, clean=True, output_path=None, parse_frontmatter=True)</code> - Download and process a Google Doc</li> <li><code>download_doc_raw(doc_id)</code> - Get unprocessed markdown</li> <li><code>download_doc_clean(doc_id, output_path=None)</code> - Get fully cleaned markdown</li> <li><code>download_docs_batch(doc_ids, clean=True, output_folder=None, use_document_names=True)</code> - Batch download</li> <li><code>clean_markdown(content, clean_escapes=True, remove_images=True, strip_heading_bold=True)</code> - Apply cleaning</li> </ul>"},{"location":"markmeld/google_drive_processor/#svg-methods","title":"SVG Methods","text":"<ul> <li><code>process_svg_folder(folder_id, skip_unchanged=True)</code> - Process all SVGs in a folder</li> <li><code>download_svg(file_id, destination_path)</code> - Download a single SVG</li> <li><code>list_svg_files(folder_id)</code> - List SVG files in a folder</li> <li><code>convert_svg_to_pdf(svg_path, pdf_path)</code> - Convert SVG to PDF using Inkscape</li> </ul>"},{"location":"markmeld/google_drive_processor/#unified-processing_1","title":"Unified Processing","text":"<ul> <li><code>process_drive_folder(folder_id, process_doc=True, process_figs=True, output_path=None)</code> - Process manuscript folder</li> <li><code>process_docs(doc_ids, output_folder=None)</code> - Convenience method for batch docs</li> <li><code>process_svgs(folder_id)</code> - Convenience method for SVG processing</li> </ul>"},{"location":"markmeld/google_drive_processor/#utility-methods","title":"Utility Methods","text":"<ul> <li><code>get_metadata(file_id)</code> - Get metadata for any file</li> <li><code>download_file(file_id, destination_path)</code> - Download any file from Drive</li> <li><code>write_to_file(content, output_path)</code> - Write content to disk</li> <li><code>sanitize_filename(filename)</code> - Clean filename for filesystem</li> </ul>"},{"location":"markmeld/google_drive_processor/#static-cleaning-methods","title":"Static Cleaning Methods","text":"<ul> <li><code>clean_escape_characters(markdown_content)</code> - Remove escape characters</li> <li><code>remove_embedded_images(markdown_content)</code> - Remove embedded images</li> <li><code>strip_bold_from_headings(markdown_content)</code> - Remove bold from headings</li> </ul>"},{"location":"markmeld/google_drive_processor/#directory-structure","title":"Directory Structure","text":"<p>The processor creates the following directory structure:</p> <pre><code>output/           # Base directory (configurable)\n\u251c\u2500\u2500 docs/        # Downloaded markdown documents\n\u251c\u2500\u2500 pdf/         # Converted PDF files from SVGs\n\u2514\u2500\u2500 digest/      # MD5 checksums for change detection\n</code></pre>"},{"location":"markmeld/google_drive_processor/#common-use-cases","title":"Common Use Cases","text":""},{"location":"markmeld/google_drive_processor/#academic-manuscript-processing","title":"Academic Manuscript Processing","text":"<pre><code># Process a complete manuscript project\nprocessor = GoogleDriveProcessor(local_base_dir=\"manuscript_output\")\n\n# Process the main folder containing manuscript and figures\nresults = processor.process_drive_folder('manuscript-folder-id')\n\n# The processor will:\n# 1. Find and download the manuscript document\n# 2. Clean and save it as markdown\n# 3. Find the 'figs' subfolder\n# 4. Convert all SVG figures to PDFs\n# 5. Track changes to avoid reprocessing unchanged files\n</code></pre>"},{"location":"markmeld/google_drive_processor/#collaborative-document-workflows","title":"Collaborative Document Workflows","text":"<pre><code># Set up for team collaboration\nprocessor = GoogleDriveProcessor(\n    credentials_path='/secure/team-credentials.json',\n    local_base_dir='team_documents'\n)\n\n# Process shared documents\nshared_docs = [\n    'proposal-doc-id',\n    'report-doc-id',\n    'presentation-notes-id'\n]\n\nresults = processor.process_docs(\n    shared_docs,\n    output_folder='team_documents/latest'\n)\n</code></pre>"},{"location":"markmeld/google_drive_processor/#using-google-docs-as-markmeld-target-sources","title":"Using Google Docs as Markmeld Target Sources","text":""},{"location":"markmeld/google_drive_processor/#overview","title":"Overview","text":"<p>Markmeld supports using Google Docs directly as content sources through special target configuration. This allows you to: - Author content in Google Docs collaboratively - Build documents without manual exports - Automatically handle figures from Google Drive folders - Cache content locally for fast rebuilds</p>"},{"location":"markmeld/google_drive_processor/#configuration-in-_markmeldyaml","title":"Configuration in <code>_markmeld.yaml</code>","text":"<p>To use a Google Doc as a target source, set the <code>type</code> field to <code>google-doc</code>:</p> <pre><code>targets:\n  my_manuscript:\n    type: google-doc  # This tells markmeld to fetch from Google Drive\n    jinja_template: template.jinja\n    output_file: manuscript.pdf\n    data:\n      google_docs:\n        doc_id: \"YOUR_GOOGLE_DOC_ID_HERE\"\n        folder_id: \"YOUR_FOLDER_ID_HERE\"  # Optional: defaults to doc's parent folder\n</code></pre>"},{"location":"markmeld/google_drive_processor/#field-options","title":"Field Options","text":"<p>The <code>google_docs</code> section supports these fields: - <code>doc_id</code> or <code>manuscript</code>: The Google Doc ID (from the document URL) - <code>folder_id</code>: Optional folder ID containing figures (SVGs, CSVs, etc.). If omitted, automatically uses the document's parent folder</p> <p>Example with alternative field name: <pre><code>data:\n  google_docs:\n    manuscript: \"1234567890abcdef\"  # Can use 'manuscript' instead of 'doc_id'\n    folder_id: \"0987654321fedcba\"\n</code></pre></p>"},{"location":"markmeld/google_drive_processor/#environment-setup","title":"Environment Setup","text":"<p>Set your Google Drive credentials using the environment variable:</p> <pre><code># Option 1: Path to credentials file\nexport MM_GOOGLE_DRIVE_CREDENTIALS=\"/path/to/service-account-key.json\"\n\n# Option 2: JSON content directly\nexport MM_GOOGLE_DRIVE_CREDENTIALS='{\"type\": \"service_account\", ...}'\n</code></pre>"},{"location":"markmeld/google_drive_processor/#getting-ids-from-google-drive","title":"Getting IDs from Google Drive","text":"<ol> <li>Document ID: </li> <li>Open your Google Doc</li> <li> <p>Find the ID in the URL: <code>https://docs.google.com/document/d/YOUR_DOC_ID_HERE/edit</code></p> </li> <li> <p>Folder ID (for figures):</p> </li> <li>Open the Google Drive folder</li> <li>Find the ID in the URL: <code>https://drive.google.com/drive/folders/YOUR_FOLDER_ID_HERE</code></li> </ol>"},{"location":"markmeld/google_drive_processor/#building-google-doc-targets","title":"Building Google Doc Targets","text":"<p>Once configured, build your target normally:</p> <pre><code># Build the target\nmm my_manuscript\n\n# Force refresh from Google Drive (bypass cache)\nmm my_manuscript --force-refresh\n\n# Clear cache before building\nmm my_manuscript --clear-cache\n\n# Check cache status\nmm my_manuscript --cache-status\n</code></pre>"},{"location":"markmeld/google_drive_processor/#processing-pipeline","title":"Processing Pipeline","text":"<p>When you build a Google Doc target, markmeld:</p> <ol> <li>Downloads the Google Doc as markdown (with automatic cleaning)</li> <li>Processes figures from the folder (specified or auto-detected):</li> <li>Uses the specified <code>folder_id</code> if provided</li> <li>Otherwise, automatically uses the document's parent folder</li> <li>Converts SVG files to PDF</li> <li>Downloads CSV and other data files</li> <li>Updates figure paths in the document</li> <li>Caches everything locally for fast rebuilds</li> <li>Continues normally as if the content was local</li> </ol>"},{"location":"markmeld/google_drive_processor/#cache-management","title":"Cache Management","text":"<p>Cached content is stored in <code>.cache/</code> relative to your <code>_markmeld.yaml</code>:</p> <pre><code>.cache/\n\u2514\u2500\u2500 {doc_id}/\n    \u251c\u2500\u2500 docs/          # Cached markdown documents\n    \u251c\u2500\u2500 converted/     # Converted figures (SVG\u2192PDF)\n    \u2514\u2500\u2500 csv/           # Downloaded CSV files\n</code></pre> <p>Cache behavior: - Documents are cached after first download - Subsequent builds use cached version unless <code>--force-refresh</code> is used - SVG\u2192PDF conversion is cached based on file checksums - Clear cache with <code>--clear-cache</code> flag or delete <code>.cache/</code> directory</p>"},{"location":"markmeld/google_drive_processor/#complete-example","title":"Complete Example","text":"<p>Here's a full example <code>_markmeld.yaml</code> for a manuscript project:</p> <pre><code>targets:\n  # Basic manuscript from Google Doc\n  manuscript:\n    type: google-doc\n    jinja_template: manuscript_template.jinja\n    output_file: \"{today}_manuscript.pdf\"\n    data:\n      google_docs:\n        doc_id: \"1a2b3c4d5e6f7g8h9i0j\"\n      variables:\n        author: \"Your Name\"\n        title: \"My Research Paper\"\n    pandoc_args:\n      - \"--pdf-engine=xelatex\"\n      - \"--citeproc\"\n\n  # Manuscript with auto-detected figures (from doc's parent folder)\n  manuscript_auto_figures:\n    type: google-doc\n    jinja_template: manuscript_template.jinja\n    output_file: \"manuscript_with_figures.pdf\"\n    data:\n      google_docs:\n        doc_id: \"1a2b3c4d5e6f7g8h9i0j\"\n        # No folder_id - uses document's parent folder automatically\n      variables:\n        figure_path: \".cache/{doc_id}/converted/\"\n\n  # Manuscript with explicit figures folder (different from parent)\n  manuscript_custom_figures:\n    type: google-doc\n    jinja_template: manuscript_template.jinja\n    output_file: \"manuscript_custom.pdf\"\n    data:\n      google_docs:\n        doc_id: \"1a2b3c4d5e6f7g8h9i0j\"\n        folder_id: \"9i8h7g6f5e4d3c2b1a0\"  # Explicit folder (e.g., shared figures folder)\n\n  # Using 'manuscript' field instead of 'doc_id'\n  research_paper:\n    type: google-doc\n    jinja_template: paper_template.jinja\n    output_file: \"research_paper.pdf\"\n    data:\n      google_docs:\n        manuscript: \"1a2b3c4d5e6f7g8h9i0j\"\n</code></pre>"},{"location":"markmeld/google_drive_processor/#jinja-template-considerations","title":"Jinja Template Considerations","text":"<p>When using Google Doc sources, the document content is available as <code>content</code> in your Jinja template:</p> <pre><code># {{ title }}\n\n**Author:** {{ author }}\n\n{{ content }}\n\n## References\n</code></pre> <p>If you have frontmatter in your Google Doc (YAML between <code>---</code> markers), it's automatically parsed and made available as variables.</p>"},{"location":"markmeld/google_drive_processor/#advantages-of-google-doc-targets","title":"Advantages of Google Doc Targets","text":"<ol> <li>Collaborative Editing: Multiple authors can work simultaneously in Google Docs</li> <li>Version Control: Google Docs provides automatic version history</li> <li>Cloud-native: No need to manually download/export documents</li> <li>Automatic Updates: Changes in Google Docs are reflected in next build</li> <li>Figure Management: Automatically handles figures from Drive folders</li> <li>Smart Caching: Fast rebuilds with intelligent cache management</li> </ol>"},{"location":"markmeld/google_drive_processor/#troubleshooting","title":"Troubleshooting","text":"<p>Common issues and solutions:</p> <ol> <li>Authentication Errors:</li> <li>Verify service account has access to the document</li> <li>Check credentials environment variable is set correctly</li> <li> <p>Share document with service account email</p> </li> <li> <p>Missing Figures:</p> </li> <li>If using auto-detection, ensure figures are in the same folder as the document</li> <li>If specifying folder_id, ensure it's correct</li> <li>Verify service account has access to the folder</li> <li> <p>Check figure paths in the document match actual filenames</p> </li> <li> <p>Cache Issues:</p> </li> <li>Use <code>--force-refresh</code> to bypass cache</li> <li>Delete <code>.cache/</code> directory for complete refresh</li> <li> <p>Check cache status with <code>--cache-status</code> flag</p> </li> <li> <p>Document Not Found:</p> </li> <li>Verify doc_id is correct (from document URL)</li> <li>Ensure document is shared with service account</li> <li>Check for typos in configuration</li> </ol>"},{"location":"markmeld/google_drive_processor/#integration-with-cicd","title":"Integration with CI/CD","text":"<p>For automated builds in CI/CD pipelines:</p> <pre><code># GitHub Actions example\nsteps:\n  - name: Set Google Credentials\n    run: echo \"${{ secrets.GOOGLE_CREDENTIALS }}\" &gt; credentials.json\n\n  - name: Build manuscript\n    env:\n      MM_GOOGLE_DRIVE_CREDENTIALS: ./credentials.json\n    run: |\n      mm manuscript --force-refresh\n</code></pre>"},{"location":"markmeld/google_drive_processor/#advanced-configuration","title":"Advanced Configuration","text":"<p>You can combine Google Doc targets with other markmeld features:</p> <pre><code>targets:\n  # Loop target for multiple documents\n  batch_reports:\n    type: google-doc\n    loop:\n      - doc_id: \"doc1_id\"\n        name: \"Report 1\"\n      - doc_id: \"doc2_id\"\n        name: \"Report 2\"\n    jinja_template: report_template.jinja\n    output_file: \"{name}_report.pdf\"\n    data:\n      google_docs:\n        doc_id: \"{doc_id}\"\n\n  # Target with prebuild/postbuild\n  manuscript_with_bib:\n    type: google-doc\n    prebuild:\n      - update_bibliography\n    data:\n      google_docs:\n        doc_id: \"manuscript_id\"\n    postbuild:\n      - extract_references\n</code></pre>"},{"location":"markmeld/google_drive_processor/#license","title":"License","text":"<p>MIT</p>"},{"location":"markmeld/imports/","title":"Imports","text":"<p>It's super useful to define global config options, and then re-use them across projects. You can do this with <code>imports</code>. So I have a global config file, say <code>path/to/other/_markmeld.yaml</code>:</p> <pre><code>targets:\n  base_target:\n    sciquill: /home/nsheff/code/sciquill/\n    figczar: /home/nsheff/code/sciquill/pandoc_filters/figczar/figczar.lua\n    highlighter: /home/nsheff/code/sciquill/pandoc_filters/change_marker/change_marker.lua\n    multirefs: /home/nsheff/code/sciquill/pandoc_filters/multi-refs/multi-refs.lua\n    csl: /home/nsheff/code/sciquill/csl/biomed-central.csl\n    bibdb: /home/nsheff/code/papers/sheffield.bib\n</code></pre> <p>Now you use: <pre><code>imports:\n  - path/to/other/_markmeld.yaml\n</code></pre></p> <p>And now I can use <code>{figczar}</code> and <code>{bibdb}</code> in <code>command</code> section of a <code>_markmeld.yaml</code> file. If you want to be really cool, maybe point to this config file with <code>$MARKMELD</code> and then use:</p> <pre><code>imports:\n  - $MARKMELD\n</code></pre> <p>It works! Imports are in priority order, and lower priority than whatever you have in the local file, like <code>css</code>.  You can also use <code>inherit_from</code> on imported targets:</p> <pre><code>imports:\n  - path/to/other/_markmeld.yaml\ntargets:\n  my_local_target:\n    inherit_from: base_target      &lt;--- defined in imported file\n    data:\n      ...\n</code></pre>"},{"location":"markmeld/imports/#relative-imports","title":"Relative imports","text":"<p>In general <code>imports</code>, any relative paths will be considered relative to the importing file. This allows you to define targets that expect some relative files, and then use those for different files of the same names in different directories.</p> <p>But sometimes you want to import a remote target and keep its relative paths relative to imported file. For that, you can use <code>imports_relative</code>:</p> <pre><code>imports:\n  - these/targets/are/relative/to/here/_markmeld.yaml\nimports_relative:\n  - these/targets/are/relative/to/there/_markmeld.yaml\n</code></pre> <p>One thing that can be tricky: if you import a file in <code>relative_imports</code>, and that file imports another, with <code>imports</code>... Then the targets in the second fill will be considered relative to the first file. That's because they are relative to the importing file, which in this case, is the first imported file. So, this can be a bit confusing if you are nesting relative imports. My advice is to just not import anything in a file that's imported with <code>imports_relative</code>.</p>"},{"location":"markmeld/inheriting/","title":"Target inheritance","text":"<p>Sometimes you want to define multiple targets that all share some content, or template, or other properties. Markmeld handles this with the <code>inherit_from</code> directive.</p> <p>Example:</p> <pre><code>targets:\n  base_target:\n    ...\n  target2:\n    inherit_from: base_target\n    data:\n      ...\n</code></pre> <p>If a target has an <code>inherit_from</code> attribute, then one or more targets will first be pre-loaded and processed. The targets are loaded in the order listed, with the specified target the last one, so attributes with the same name will have the highest priority.</p>"},{"location":"markmeld/install/","title":"Install","text":"<p>Use some variant of:</p> <pre><code>pip install markmeld\n</code></pre>"},{"location":"markmeld/install/#testing","title":"Testing","text":"<p>Markmeld provides the <code>mm</code> executable. You can test using the demos in the mm repository if you clone it:</p> <pre><code>cd demo\nmm default\n</code></pre> <p>This will produce the output, automatically piping to pandoc. You can also get the raw output with <code>-p</code>, like this:</p> <pre><code>mm default -p &gt; rendered.md\n</code></pre> <p>Next, move on to basic configuration.</p>"},{"location":"markmeld/jinja_template/","title":"Writing Jinja templates for markmeld","text":"<p>The data content for a target is specified in the markmeld config through a variety of options under a target's <code>data</code> attribute, such as <code>md_files</code>, <code>yaml_globs</code>, and more. Markmeld loads this data and then runs it through a jinja template. To write a template, you'll need to be able to reference specific data elements. This document explains how to do that for each of the various ways of specifying data for a target.</p>"},{"location":"markmeld/jinja_template/#_files-directives","title":"<code>*_files</code> directives","text":"<p>For <code>md_files</code>, <code>yaml_files</code> you specify a key for each file, and your content will be available under the key you defined. For example, if you have the following <code>_markmeld.yaml</code> file:</p> <pre><code>targets:\n  my_target:\n    data:\n      md_files:\n        my_md_file: path/to/file1.md\n      yaml_files:\n        my_yaml_file: path/to/file2.yaml\n</code></pre> <p>You can then access them in the jinja template as jinja variables, like this. For markdown files, the content is directly accessible using the key:</p> <pre><code>{{ my_md_file }}\n</code></pre> <p>You can also access the frontmatter for an individual <code>.md</code> file with <code>{{ _local_frontmatter.my_md_file }}</code>.</p> <p>For yaml files, using the key directly will get you a dictionary of the yaml content, which you can then access using sub-attributes, like this:</p> <pre><code>{{ my_yaml_file.variable_defined_in_file2 }}\n</code></pre>"},{"location":"markmeld/jinja_template/#_globs-directives","title":"<code>*_globs</code> directives","text":"<p>If you are using the <code>md_globs</code>, or <code>yaml_globs</code> directives, the content of the files will be available under corresponding filename (without extension). For example, for this config file:</p> <pre><code>targets:\n  my_target:\n    data:\n      md_globs:\n        - path/to/file1.md\n      yaml_globs:\n        - path/to/file2.yaml\n</code></pre> <p>You'd reference content in your jinja template with:</p> <pre><code>{{ file1 }}\n\n{{ file2.variable_defined_in_file2 }}\n</code></pre>"},{"location":"markmeld/jinja_template/#yaml_globs_unkeyed-directive","title":"<code>yaml_globs_unkeyed</code> directive","text":"<p>The <code>yaml_globs_unkeyed</code> directive behaves a bit differently. Unlike markdown content, yaml content can be keyed natively (within the file), and sometimes you may need to rely on these keys directly, instead of using a filename, the yaml content is available directly as specified in the file.  Your markdown items will be available under the key you specify in the config. </p>"},{"location":"markmeld/jinja_template/#special-variables","title":"Special variables","text":"<p>In addition to the variables you define in your <code>data</code> section, you'll automatically have access to some markmeld-produced variables:</p> <ul> <li><code>{_today}</code>: Today's date in standard form (YYYY-MM-DD).</li> <li><code>{_now}</code>: Current time in seconds since UNIX epoch.</li> <li><code>{_global_frontmatter}</code>: Integrated frontmatter across all provided <code>.md</code> files. (Details below)</li> <li><code>{_local_frontmatter}</code>: Array of frontmatter from individual markdown files.</li> <li><code>{_md}</code>: the keyed content you specified in your <code>_markmeld.yaml</code> config in <code>md_files</code> and <code>md_globs</code>.</li> <li><code>{_yaml}</code>:  the keyed content you specified in your <code>_markmeld.yaml</code> config in <code>md_files</code> and <code>md_globs</code>.</li> </ul>"},{"location":"markmeld/jinja_template/#global-frontmatter","title":"Global frontmatter","text":"<p>The <code>{{ _global_frontmatter }}</code> is a really useful markmeld-produced variable that integrates frontmatter across all provided sources programatically. The rationale here is that you may be combining a bunch of <code>.md</code> files, each with its own frontmatter, and you may also want to supplement that with standalone <code>.yaml</code> files that are also defining frontmatter. If your goal is to produce an integrated document, then what you want is a merged frontmatter block that combines the variables from all of these sources. </p> <p>You could just write a jinja template to integrate them, but then you could accidentally include the same information multiple times; this is complicated to handle with jinja in every template, and pandoc also chokes if you provide multiple of the same key. To address this, markmeld provides the <code>_global_frontmatter</code> variable, which integrates your yaml frontmatter within markmeld. This will accumulate any yaml information from:</p> <ul> <li>The frontmatter on any <code>.md</code> files included via <code>md_files</code> or <code>md_globs</code>.</li> <li>Any yaml that is keyed with the regex <code>frontmatter_*</code>, from <code>yaml_files</code> or <code>yaml_globs</code>. There is no way to add frontmatter from <code>yaml_globs_unkeyed</code>.</li> <li>Any variables with keys that match the regex <code>frontmatter_*</code>, where the <code>*</code> will be used as the keys added to the frontmatter.</li> </ul> <p>When values clash, the priority is as listed above. Markmeld then formats the final values into 3 different forms, so you can access these for various use cases. The 3 variables are:</p> <ul> <li><code>{{_global_frontmatter.fenced}}</code> -- in raw, fenced yaml. Useful if you want to produce integrated frontmatter for an output <code>.md</code> file. If the frontmatter is empty, fences are automatically omitted.</li> <li><code>{{_global_frontmatter.raw}}</code> -- in raw, unfenced yaml.</li> <li><code>{{_global_frontmatter.dict}}</code> -- A dict version, so you can access individual elements, like <code>{{_global_frontmatter.dict.var2}}</code></li> </ul>"},{"location":"markmeld/jinja_template/#local-frontmatter","title":"Local frontmatter","text":"<p>Sometimes you need to access the frontmatter from a specific md file, rather than the global integrated version. You can also do that with: <code>_local_frontmatter.&lt;VAR&gt;</code>, Where <code>&lt;VAR&gt;</code> is the key for the markdown file. Like the <code>_global_frontmatter</code> variable, local frontmatter is also provided in 3 forms: <code>_local_frontmatter.&lt;VAR&gt;.fenced</code>, <code>_local_frontmatter.&lt;VAR&gt;.raw</code>, and <code>_local_frontmatter.&lt;VAR&gt;.dict</code>.</p>"},{"location":"markmeld/jinja_template/#raw-content","title":"Raw content","text":"<p>Sometimes I want the actual file itself, not processed at all. That's available in <code>_raw.&lt;VAR&gt;</code></p>"},{"location":"markmeld/jinja_template/#variables","title":"Variables","text":"<p><code>_global_vars.&lt;VAR&gt;</code> is under construction. I'm still trying to see if this is useful.</p>"},{"location":"markmeld/mail_merge/","title":"How to write mail-merge letters with markmeld","text":""},{"location":"markmeld/mail_merge/#1-data","title":"1. Data","text":"<p>You need a <code>data.yaml</code> file like this. This is a list of people you want to send the letter to:</p> <pre><code>people:\n  - first_name: Bob\n    last_name: Jones\n    email: bob.jones@gmail.com\n</code></pre>"},{"location":"markmeld/mail_merge/#2-letter","title":"2. Letter","text":"<p>Write your letter in a jinja template like this <code>letter.jinja</code>:</p> <pre><code>{% for person in people %}\n\n&lt;a href=\"mailto:{{ person.email }}?subject=SUBJECT&amp;body=Hi {{person.first_name}},%0D%0A%0D%Letter contentt %0D%0A%0D%0AThanks, and we should catch up some time!%0D%0A%0D%0A-Nathan\"&gt;{{ person.first_name }}&lt;/a&gt;\n\n{% endfor %}\n</code></pre>"},{"location":"markmeld/mail_merge/#3-markmeld-config-in-_markmeldyaml","title":"3. Markmeld config in <code>_markmeld.yaml</code>:","text":"<p>Which is something like:</p> <pre><code>imports:\n  - $MMDIR/$HOSTNAME.yaml\ntargets:\n  links:\n    jinja_template: letter_template.jinja\n    output_file: \"{today}.html\"\n    data_yaml:\n      - data.yaml\n    command: |\n      pandoc \\\n        -o {output_file}\n</code></pre> <p>Now just <code>mm links</code>, open the file, and you have personalized click links for all your letters. Easy peasy!</p>"},{"location":"markmeld/multi_output_targets/","title":"Multi-output targets","text":"<p>Typical targets produce only a single output. But sometimes, it's useful to specify a single target and have it produce multiple outputs, which we call multi-output targets. To define a multi-output target, you  specify a loop variable in the target definition, which has two sub-variables: an array (with the content to iterate over for each output), and a variable name to populate with each array element. </p>"},{"location":"markmeld/multi_output_targets/#motivation","title":"Motivation","text":"<p>This is useful for something like a mail merge, where you'd write a single letter, but want to produce it with slight differences such as the name of the recipient. Another use case is that you want to load in a large piece of data one time (like a list of publications), and then produce several different versions or subsets of it without reloading the input.</p> <p>The use case for multi-output targets is really intended for outputs that are almost identical. If you want one target to produce two or more targets that are very different, then your best bet is to define each target separately and then use a meta-target to build them simultaneously.</p>"},{"location":"markmeld/multi_output_targets/#quick-start","title":"Quick start","text":"<p>Create a multi-output target by adding a loop variable to a target in <code>_markmeld.yaml</code>:</p> <pre><code>targets:\n  target_name:\n    loop:\n      loop_data: recipients\n      assign_to: recipient\n</code></pre> <p>The loop attribute has two sub-attributes:</p> <ul> <li>loop_data: Specify the name of the object that contains the array you want to loop over. This target will create one output per element in this array. The array can be either of primitive types (like strings), or can be an array of objects.</li> <li>assign_to: This is the name of the variable that each element in loop_data will be assigned to. This is how you will access the individual element, both in the command templates and in the jinja templates.</li> </ul>"},{"location":"markmeld/multi_output_targets/#loop-data-array-of-strings","title":"Loop data: array of strings","text":"<p>In the simple example, the array data (found in <code>some_data.yaml</code>) looks like this:</p> <pre><code>recipients:\n  - \"John Doe\"\n  - \"Jane Doe\"\n</code></pre> <p>This target will create 1 output for each recipient.</p>"},{"location":"markmeld/multi_output_targets/#loop-data-array-of-objects","title":"Loop data: array of objects","text":"<p>If you have a more complicated needs, like more than one element per loop iteration, then you can use an array of objects like this:</p> <pre><code>recipients:\n  - name: \"John Doe\"\n    institution: \"University of Virginia\"\n  - name: \"Jane Doe\"\n    institution: \"Brigham Young University\"\n</code></pre> <p>See how the <code>_markmeld.yaml</code> file uses this information:</p> <pre><code>targets:\n  default:\n    output_file: \"{today}_demo_output_{recipient}.pdf\"\n    jinja_template: jinja_template.jinja\n    recursive_render: false\n    loop:\n      loop_data: recipients\n      assign_to: recipient\n    data:\n      md_files:\n        some_text_data: some_text.md\n      yaml_globs_unkeyed:\n      - some_data.yaml\n  complex_loop:\n    output_file: \"{today}_demo_output_complex_{recipient[name]}.pdf\"\n    jinja_template: jinja_template_complex.jinja\n    recursive_render: false\n    loop:\n      loop_data: recipients\n      assign_to: recipient\n    data:\n      md_files:\n        some_text_data: some_text.md\n      yaml_globs_unkeyed:\n      - complex_loop.yaml\n</code></pre> <p>We just have to make sure the <code>output_file</code> variable uses the <code>assign_to</code> variable in some way (in this case, it's <code>{recipient}</code>). This will create a separate output, with a separate output file name, for each iteration of the loop. The jinja template specified in <code>md_template</code> should also use <code>recipient</code>, so that each output is unique.</p> <p>You thus produce multiple outputs with a single <code>mm</code> build call.</p>"},{"location":"markmeld/prevent_opening/","title":"Preventing automatic opening","text":"<p>By default, markmeld will try to open targets after it builds them, so you can immediately view them. You might not want this behavior. For a certain target, you can turn off auto-open by adding <code>stopopen: true</code> to the target.</p>"},{"location":"markmeld/recursive_rendering/","title":"Recursive rendering","text":""},{"location":"markmeld/recursive_rendering/#recursive-rendering","title":"Recursive rendering","text":"<p>If you want a jinja variable to hold a variable, then you'll have to render the template recursively. Really, we'll just render it twice, since that's all I've needed so far.</p> <p>But sometimes, you don't want to render it recursively, like if you want to actually show jinja variables in an output. So, we need it to be possible to choose for a given target. You do that with <code>recursive_render</code>, which can be True (default) or False.</p> <p>So, generally you don't need to worry about this, and you can automatically go 2 layers deep, which means your variables can contain jinja variables. But if you want to turn it off, do it with:</p> <pre><code>targets:\n  my_non_recursive_target:\n    recursive_render: false\n    data:\n      ...\n</code></pre>"},{"location":"markmeld/remote_templates/","title":"How to use a remote template repository","text":"<p>Complete instructions for remote templates can be found at databio.org/mm_templates.</p>"},{"location":"markmeld/side_targets/","title":"Side targets","text":"<p>Side targets are additional targets that are built along with a target, either before or after the primary target is built. </p> <p>For example, you can add a 'prebuild' attribute in <code>_markmeld.yaml</code>:</p> <pre><code>targets:\n  prep_target1:\n    ...\n  prep_target2:\n    ...    \n  main_target:\n    prebuild: \n    - prep_target1\n    - prep_target2\n</code></pre> <p>The values under <code>prebuild</code> must be the keys of other targets. If you build <code>main_target</code>, Markmeld will first build the <code>prebuild</code> targets in the order listed before building the requested target. You can also specify <code>postbuild</code> targets. These targets will be built after the primary target is built.</p> <pre><code>targets:\n  post_target1:\n    ...\n  post_target2:\n    ...    \n  main_target:\n    postbuild: \n    - post_target1\n    - post_target2\n</code></pre> <p>The <code>prebuild</code> and <code>postbuild</code> side targets must be defined somewhere, but you could define them either in the same configuration file or in an imported configuration file. I'm using prebuild targets to build figures to make sure they are updated before a manuscript build, or to splitting a PDF into different pages after building. For these use cases, it makes sense for your pre-build targets to be of <code>type: raw</code>, since they won't actually produce markmeld outputs directly.</p>"},{"location":"markmeld/simple_example/","title":"Simple example tutorial","text":""},{"location":"markmeld/simple_example/#definition-of-terms","title":"Definition of terms","text":"<ul> <li>configuration file - A <code>yaml</code> file that configures markmeld and specifies targets (Default:  <code>_markmeld.yaml</code>).</li> <li>target - A specific recipe to run that usually builds an output.</li> <li>data - Content, either in markdown or yaml format, used to produce a target.</li> <li>template - A jinja2 file defining how the input will be integrated to produce the output.</li> </ul>"},{"location":"markmeld/simple_example/#a-simple-example","title":"A simple example","text":"<p>Here's <code>demo/_markmeld.yaml</code>, a simple example that produces a single basic target:</p> <pre><code>targets:\n  target1:\n    output_file: \"{today}_demo_output.pdf\"  \n    latex_template: pandoc_default.tex\n    jinja_template: jinja_template.jinja\n    command: |\n        pandoc --template \"{latex_template}\" --output \"{output_file}\"\n    data:\n      yaml_files:\n        - some_data.yaml\n      md_files:\n        some_text_data: some_text.md\n</code></pre> <p>This file specifies a single target, <code>target1</code>. This target can be built by specifying <code>mm target1</code> on the command line. Building target1 will read structured data from <code>some_data.yaml</code> and prose from <code>some_text.md</code>, integrated through the <code>jinja_template.jinja</code>. The integrated output of the template will be piped to <code>stdin</code> of the <code>pandoc</code> command to produce the output file named in the <code>output_file</code> variable.</p>"},{"location":"markmeld/simple_example/#using-the-command-line","title":"Using the command line","text":"<p>Markmeld gives you a series of CLI arguments:</p> <ul> <li><code>mm</code> - List available targets concisely</li> <li><code>mm -c &lt;config&gt;</code> - Specify a different config file (defaults to <code>_markmeld.yaml</code>).</li> <li><code>mm -l</code> - List the available targets with their descriptions.</li> <li><code>mm &lt;target&gt;</code> - Builds the target</li> <li><code>mm &lt;target&gt; -p</code> - Prints out the output (what would be piped to the command on <code>stdin</code>)</li> <li><code>mm &lt;target&gt; -d</code> - Dumps the structured input before melding with jinja, so you can see what your jinja template will be receiving. Useful for troubleshooting jinja templates.</li> <li><code>mm &lt;target&gt; -e</code> - Explains the target -- shows you from the config file what this target is actually doing.</li> </ul>"},{"location":"markmeld/target_factories/","title":"Target factories","text":"<p>Target factories^1 are functions that generate targets programatically. Without target factories, every target must be specified individually in your <code>_markmeld.yaml</code> config file. With target factories, you can add multiple targets with a single definition. These targets are added programatically using a function call . For example, a target factory could build targets from an external data source, or a list of files in a directory. Target factories provide a powerful way to produce a lot of targets with very little effort. </p>"},{"location":"markmeld/target_factories/#example-use-case","title":"Example use case","text":"<p>Say I have a folder with a bunch of <code>.md</code> files and I'd like to build a separate PDF for each one. If I want a single target that builds all the PDFs at once, I could use a multi-output target. But if I want to build each one independently, I need a separate target for each file. I could add each target to the <code>_markmeld.yaml</code> file and that would work, but wouldn't it be nice if I could somehow just say, \"I want every markdown file in this folder to be its own target\", and then leave it at that? That's what target factories do. With a target factory, I could add a new target to the project by just adding a new <code>.md</code> file to the folder -- no change would be required in <code>_markmeld.yaml</code>.</p>"},{"location":"markmeld/target_factories/#how-to-use-target-factories","title":"How to use target factories","text":"<p>There are built-in target factories and custom target factories. You can use built-in factories with no further prerequisites.</p>"},{"location":"markmeld/target_factories/#1-built-in-target-factories","title":"1. Built-in target factories","text":"<p>Right now there is 1 built-in factory, called the glob factory. </p>"},{"location":"markmeld/target_factories/#glob-factory","title":"Glob factory","text":"<p>The <code>glob</code> factory solves the above use case. You have a bunch of <code>.md</code> files and you want a target for each one. You can invoke the glob factory in your <code>_markmeld.yaml</code> config file like this:</p> <pre><code>target_factories:\n- glob:\n    path: \"*.md\"\n- glob:\n    name_levels: 2\n    path: \"*/*.md\"\n    glob_variables:\n      jinja_template: ...    \n</code></pre> <p>Parameters for <code>glob</code> factory:</p> <ul> <li><code>path</code>: A Python <code>glob</code> (regular expression) for paths to markdown files.</li> <li><code>name_levels</code>: How many levels down do want to go for target names, and output file names? You use this to have nested targets. For example, for <code>.md</code> files in the same folder, you'd leave this at the default (<code>1</code>). If you have folders, and each <code>.md</code> file is in a subfolder, you'd use <code>name_levels: 2</code>. So, it's the number of folders deep you want to use for your target names and output files.</li> <li><code>glob_variables</code>: Any additional variables you want to pass to the targets generated by this particular factory.</li> </ul>"},{"location":"markmeld/target_factories/#2-custom-target-factories","title":"2. Custom target factories","text":"<p>You can also write your own target factories, which we call custom target factories. Custom target factories are Python packages. Once you've installed the package, you can use the target factory just like a built-in factory. To create one, you just have to follow 2 guidelines:</p>"},{"location":"markmeld/target_factories/#21-add-entry_points-to-setuppy","title":"2.1. Add entry_points to setup.py","text":"<p>The <code>setup.py</code> file uses <code>entry_points</code> to map target factory name to function.</p> <pre><code>entry_points={\n    'markmeld.factories': 'factory_name=packagename:my_function',\n    }\n</code></pre> <p>The format is: 'markmeld.factories': 'FACTORY_NAME=FACTORY_PACKAGE_NAME:FUNCTION_NAME'.</p> <ul> <li>\"FACTORY_NAME\" can be any unique identifier for your factory</li> <li>\"FACTORY_PACKAGE_NAME\" must be the name of python package the holds your factory.</li> <li>\"FUNCTION_NAME\" must match the name of the function in your package</li> </ul>"},{"location":"markmeld/target_factories/#22-write-functions-to-call","title":"2.2. Write functions to call","text":"<p>The factory function name must correspond to what you specify in <code>setup.py</code> in the entry points above. These functions must take exactly 2 arguments. The first is a Python <code>dict</code> object representing variables configuring this factory, the second is the parent config file object. The function must return a <code>targets</code> object. The <code>dict</code> object provided will be any additional variables given by the user in <code>_markmeld.yaml</code>, which is how users can parameterize the factory. For example:</p> <pre><code>target_factories:\n- glob:\n    path: \"*/*.md\"\n    name: \"folder\"\n</code></pre> <p>Markmeld will pass this object to the registered function for the <code>glob</code> factory:</p> <pre><code>{ path: \"*/*.md\"\n  name: \"folder\": }\n</code></pre> <p>The function is expected to return a <code>targets</code> object, that will be used to <code>update</code> the <code>targets</code> object specified in <code>_markmeld.yaml</code>.</p> <p>[^1]: Name borrowed from the excellent targets R package.</p>"},{"location":"markmeld/use_as_library/","title":"Using markmeld as a library","text":"<p>While markmeld is primarily designed as a command-line tool, it can also be used as a Python library for programmatic document generation. This is particularly useful when you need to:</p> <ul> <li>Generate documents dynamically from application data</li> <li>Integrate markmeld into larger Python applications</li> <li>Build documents without creating intermediate files</li> <li>Programmatically create and modify configurations</li> </ul>"},{"location":"markmeld/use_as_library/#basic-usage","title":"Basic usage","text":"<p>The core class for library usage is <code>MarkdownMelder</code>. Here's a simple example:</p> <pre><code>import yaml\nfrom markmeld import MarkdownMelder, load_config_file\n\n# Load configuration from a file\ncfg = load_config_file(\"_markmeld.yaml\")\n\n# Create a MarkdownMelder instance\nmm = MarkdownMelder(cfg)\n\n# Build a target (render only, don't run command)\nresult = mm.build_target(\"my_target\", print_only=True)\n\n# Access the rendered output\nprint(result.melded_output)\n</code></pre>"},{"location":"markmeld/use_as_library/#direct-content-input-no-files-needed","title":"Direct content input (no files needed)","text":"<p>Starting with version 0.5.0, markmeld supports providing content directly without creating files on disk. This is achieved through two new configuration keys: <code>md_content</code> and <code>yaml_content</code>.</p>"},{"location":"markmeld/use_as_library/#example-markdown-content-from-strings","title":"Example: Markdown content from strings","text":"<pre><code>import yaml\nfrom markmeld import MarkdownMelder\n\n# Create configuration programmatically\nconfig = {\n    \"_cfg_file_path\": \"/tmp/temp.yaml\",  # Required for path resolution\n    \"targets\": {\n        \"letter\": {\n            \"_workpath\": \"/tmp\",  # Required working directory\n            \"_defpath\": \"/tmp\",   # Required definition path\n            \"data\": {\n                \"md_content\": {\n                    \"body\": \"Dear {{name}},\\n\\nThank you for your purchase of {{product}}.\\n\\nBest regards,\\nThe Team\"\n                },\n                \"yaml_content\": {\n                    \"customer\": {\n                        \"name\": \"John Doe\",\n                        \"product\": \"Premium Widget\"\n                    }\n                }\n            },\n            \"jinja_template\": \"letter_template.jinja\",\n            \"command\": None  # Just render, don't execute\n        }\n    }\n}\n\n# Create melder and build\nmm = MarkdownMelder(config)\nresult = mm.build_target(\"letter\", print_only=True)\nprint(result.melded_output)\n</code></pre>"},{"location":"markmeld/use_as_library/#example-markdown-with-frontmatter","title":"Example: Markdown with frontmatter","text":"<p>You can provide markdown content with frontmatter metadata:</p> <pre><code>from markmeld import MarkdownMelder\n\nconfig = {\n    \"_cfg_file_path\": \"/tmp/temp.yaml\",\n    \"targets\": {\n        \"blog_post\": {\n            \"_workpath\": \"/tmp\",\n            \"_defpath\": \"/tmp\",\n            \"data\": {\n                \"md_content\": {\n                    \"post\": {\n                        \"content\": \"# My Blog Post\\n\\nThis is the content.\",\n                        \"frontmatter\": {\n                            \"title\": \"Amazing Post\",\n                            \"author\": \"Jane Smith\",\n                            \"date\": \"2024-01-15\",\n                            \"tags\": [\"python\", \"documentation\"]\n                        }\n                    }\n                }\n            },\n            \"jinja_template\": \"blog_template.jinja\",\n            \"command\": None\n        }\n    }\n}\n\nmm = MarkdownMelder(config)\nresult = mm.build_target(\"blog_post\", print_only=True)\n\n# Frontmatter is available in _global_frontmatter\nprint(result.melded_input['_global_frontmatter']['dict']['title'])  # \"Amazing Post\"\n</code></pre>"},{"location":"markmeld/use_as_library/#example-using-python-frontmatter-objects","title":"Example: Using python-frontmatter objects","text":"<p>If you're already working with the <code>python-frontmatter</code> library, you can pass Post objects directly:</p> <pre><code>import frontmatter\nfrom markmeld import MarkdownMelder\n\n# Create a frontmatter Post object\npost = frontmatter.Post(\"# Document Title\\n\\nDocument content here.\")\npost.metadata = {\n    \"author\": \"John Doe\",\n    \"version\": \"1.0\",\n    \"date\": \"2024-01-01\"\n}\n\nconfig = {\n    \"_cfg_file_path\": \"/tmp/temp.yaml\",\n    \"targets\": {\n        \"document\": {\n            \"_workpath\": \"/tmp\",\n            \"_defpath\": \"/tmp\",\n            \"data\": {\n                \"md_content\": {\n                    \"doc\": post  # Pass the Post object directly\n                }\n            },\n            \"jinja_template\": \"doc_template.jinja\",\n            \"command\": None\n        }\n    }\n}\n\nmm = MarkdownMelder(config)\nresult = mm.build_target(\"document\", print_only=True)\n</code></pre>"},{"location":"markmeld/use_as_library/#programmatic-configuration-building","title":"Programmatic configuration building","text":"<p>You can build configurations programmatically for dynamic document generation:</p> <pre><code>from markmeld import MarkdownMelder\nimport json\n\ndef generate_report(data_dict, template_path):\n    \"\"\"Generate a report from a data dictionary\"\"\"\n\n    config = {\n        \"_cfg_file_path\": \"dynamic_config.yaml\",\n        \"targets\": {\n            \"report\": {\n                \"_workpath\": \".\",\n                \"_defpath\": \".\",\n                \"data\": {\n                    \"yaml_content\": {\n                        \"report_data\": data_dict\n                    },\n                    \"md_content\": {\n                        \"summary\": f\"# Report for {data_dict.get('client_name', 'Unknown')}\\n\\nGenerated on {data_dict.get('date', 'today')}\"\n                    }\n                },\n                \"jinja_template\": template_path,\n                \"command\": \"pandoc --output report.pdf\"\n            }\n        }\n    }\n\n    mm = MarkdownMelder(config)\n    return mm.build_target(\"report\")\n\n# Use the function\nreport_data = {\n    \"client_name\": \"Acme Corp\",\n    \"date\": \"2024-01-15\",\n    \"metrics\": {\n        \"revenue\": 1000000,\n        \"growth\": \"15%\"\n    }\n}\n\nresult = generate_report(report_data, \"templates/report.jinja\")\n</code></pre>"},{"location":"markmeld/use_as_library/#combining-file-and-content-sources","title":"Combining file and content sources","text":"<p>You can mix file-based and content-based data sources:</p> <pre><code>config = {\n    \"_cfg_file_path\": \"config.yaml\",\n    \"targets\": {\n        \"combined\": {\n            \"_workpath\": \".\",\n            \"_defpath\": \".\",\n            \"data\": {\n                # From files\n                \"md_files\": {\n                    \"header\": \"templates/header.md\",\n                    \"footer\": \"templates/footer.md\"\n                },\n                \"yaml_files\": {\n                    \"config\": \"config/settings.yaml\"\n                },\n                # From memory\n                \"md_content\": {\n                    \"dynamic_section\": generated_markdown_content\n                },\n                \"yaml_content\": {\n                    \"runtime_data\": {\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"user\": os.getenv(\"USER\")\n                    }\n                }\n            },\n            \"jinja_template\": \"combined_template.jinja\",\n            \"command\": None\n        }\n    }\n}\n</code></pre>"},{"location":"markmeld/use_as_library/#working-with-melded-output","title":"Working with melded output","text":"<p>The <code>build_target</code> method returns a Target object with useful attributes:</p> <pre><code>result = mm.build_target(\"my_target\", print_only=True)\n\n# Access the rendered output\nprint(result.melded_output)\n\n# Access the input data that was passed to the template\nprint(result.melded_input.keys())\n\n# Check the return code (0 for success)\nprint(result.returncode)\n\n# Access target metadata\nprint(result.meta)\n</code></pre>"},{"location":"markmeld/use_as_library/#using-with-loops","title":"Using with loops","text":"<p>You can use markmeld's loop functionality programmatically:</p> <pre><code>config = {\n    \"_cfg_file_path\": \"config.yaml\",\n    \"targets\": {\n        \"mail_merge\": {\n            \"_workpath\": \".\",\n            \"_defpath\": \".\",\n            \"loop\": {\n                \"loop_data\": \"recipients\",\n                \"assign_to\": \"recipient\"\n            },\n            \"data\": {\n                \"yaml_content\": {\n                    \"recipients\": [\n                        {\"name\": \"Alice\", \"email\": \"alice@example.com\"},\n                        {\"name\": \"Bob\", \"email\": \"bob@example.com\"},\n                        {\"name\": \"Charlie\", \"email\": \"charlie@example.com\"}\n                    ]\n                },\n                \"md_content\": {\n                    \"template\": \"Dear {{recipient.name}},\\n\\nYour email is {{recipient.email}}.\"\n                }\n            },\n            \"jinja_template\": \"email.jinja\",\n            \"output_file\": \"emails/{{recipient.name}}.txt\",\n            \"command\": None\n        }\n    }\n}\n\nmm = MarkdownMelder(config)\nresults = mm.build_target(\"mail_merge\", print_only=True)\n\n# Results will be a dict with one entry per loop iteration\nfor idx, result in results.items():\n    print(f\"Email {idx}: {result.melded_output}\")\n</code></pre>"},{"location":"markmeld/variable_variables/","title":"Advanced templates: variable variables","text":""},{"location":"markmeld/variable_variables/#motivation","title":"Motivation","text":"<p>In a typical markmeld application, you'll encode the structure of your document within the jinja file. That's great. But to make the template reusable, sometimes it's convenient to do things like specify a list of items that show up somewhere in the document. For example, you may want a template to display a list of files in the output. If you encoded this directly, you'd have to change the template if the number of files changed. Here, we'll walk through a better alternative that uses markmeld <code>data_variables</code> with a jinja loop through the <code>md</code> array.</p>"},{"location":"markmeld/variable_variables/#the-markmeld-_md-array","title":"The markmeld <code>_md</code> array","text":""},{"location":"markmeld/variable_variables/#how-to-access-variable-named-elements","title":"How to access variable-named elements","text":"<p>Here's an example. Say I'm writing a book on finances. I have 3 chapters: intro, credit, and savings, each written in its own <code>.md</code> file. To start, I write a simple <code>_markmeld.yaml</code> config file that loads each chapter into an object:</p> <pre><code>targets:\n  default:\n    jinja_template: book.jinja\n    output_file: \"{today}_demo_output.pdf\"\n    data_md:\n      intro: md/01-intro.md\n      credit: md/02-credit.md\n      savings: md/03-savings.md\n</code></pre> <p>My <code>book.jinja</code> template could simply be like this, which puts the chapters in order:</p> <pre><code>{{ intro }}\n{{ credit }}\n{{ savings }}\n</code></pre> <p>Great. That works. But the problem is that this jinja template is specific now to this particular set of chapters, and adding new chapters means changing the template, which is a pain. Could I make <code>book.jinja</code> adaptable and generic, so it will work with any chapters I add, and even extend to work with any book I may write in the future, regardless of what I name the chapter files and variables? Yes! You can do this using the magic of <code>data.variables</code>. Instead of specifying chapters directly in <code>book.jinja</code>, we'll take advantage of 2 markmeld features: 1. The <code>_md</code> variable contains an array of all the <code>.md</code> files in our target's <code>data</code>, indexed by key we specify; and 2. we can specify custom data to the jinja tempalte using <code>data.variables</code>. We'll define an array of variable names, and then use a jinja loop to loop through that array and use those values to index into the <code>_md</code> object.</p>"},{"location":"markmeld/variable_variables/#the-md-array","title":"The <code>md</code> array","text":"<p>Markmeld makes available to jinja an array under the name <code>md</code> which has access to all of the markdown elements keyed by their names. So, while you can access the intro chapter directly with <code>{{ intro }}</code>, you can also access it through the <code>md</code> array using <code>{{ _md[\"intro\"].content }}</code>. Take it one step further, and this means if you have \"intro\" in a variable, say <code>myvar</code>, you could access the exact same content with <code>{{ _md[myvar].content }}</code>.</p> <p>So, let's set up an array with values as the chapter names by adding this to <code>_markmeld.yaml</code>:</p> <pre><code>  target:\n    data:\n      variables:\n        chapters:\n          - intro\n          - credit\n          - savings\n</code></pre> <p>This will give us access in the jinja template to a <code>chapters</code> array with those 3 values in it. So, we can switch the markmeld template to use this array like so...</p> <pre><code>{% for chapter in chapters %}\n{{ _md[chapter].content }}\n{% endfor %}\n</code></pre> <p>And voila! We have the same output, but now we've encoded the chapter order logic in the markmeld config file, and this jinja template can be reused. It's beautiful.</p>"},{"location":"markmeld/variable_variables/#_md-array-properties","title":"<code>_md</code> array properties","text":"<p>In addition to the <code>.content</code> property, for each <code>md</code> file, you can also access other stuff:</p> <ul> <li><code>_md[id].content</code> - content of the file</li> <li><code>_md[id].path</code> - path to the file (relative to <code>_markmeld.yaml</code>)</li> <li><code>_md[id].frontmatter</code> - frontmatter in the md file</li> <li><code>_md[id].ext</code> - file extension</li> </ul>"},{"location":"markmeld/variable_variables/#_yaml-array","title":"<code>_yaml</code> array","text":"<p>The <code>_yaml</code> array operates in much the same way, though it doesn't provide a <code>.frontmatter</code> since there's no frontmatter to a yaml array. So it just provides:</p> <ul> <li><code>_md[id].content</code> - content of the file</li> <li><code>_md[id].path</code> - path to the file (relative to <code>_markmeld.yaml</code>)</li> <li><code>_md[id].ext</code> - file extension</li> </ul>"},{"location":"sciquill/","title":"Sciquill","text":"<p>test</p>"},{"location":"sciquill/biosketch/","title":"NIH Biosketch","text":"<p>Like any markmeld target, building a biosketch simply requires specifying the inputs, the jinja template, and the</p> <p>You can build an NIH biosketch from structured YAML/md input using markmeld. A demo showing how this works is in https://github.com/databio/sciquill/tree/master/examples/biosketch_simple.</p>"},{"location":"sciquill/biosketch/#user-provided-inputs","title":"User-provided Inputs","text":"<p>Basically, as a user who wants to build a biosketch, you need to provide markmeld with a few things:</p>"},{"location":"sciquill/biosketch/#1-structured-personal-data-in-yaml-format","title":"1. Structured personal data in YAML format","text":"<p>Use a <code>.yaml</code> file for you biographical data. For example, it looks something like this:</p> <pre><code>personal:\n  last_name: Sheffield\n  given_name: Nathan C.\n  title: PhD\n  web: https://www.databio.org\n  eracommons: NSHEFF\n\n...\n</code></pre> <p>I add in other information like training positions, honors, etc. See the complete example here.</p>"},{"location":"sciquill/biosketch/#2-written-statements-in-markdown-format","title":"2. Written statements in markdown format","text":"<p>I have my personal statement and each of the 5 contributions stored as a markdown file. This is pretty basic, just a text file with prose in it.</p>"},{"location":"sciquill/biosketch/#3-references","title":"3. References","text":"<p>You need to pass any references to markmeld in <code>yaml</code> format. Then, you can cite them using <code>pandoc-citeproc</code> and then you cite them in the personal statement or contributions with simple <code>@key</code> syntax.</p>"},{"location":"sciquill/biosketch/#sciquill-provided-inputs","title":"Sciquill-provided inputs","text":"<p>Markmeld also requires the templates that take your structure data and produce the desired output. Since I've already built these for my own biosketch, you can just use them as is, as long as you follow the examples to fit these templates. Or, of course, you're free to write your own if you want to do this in a different way. But the two templates you have to provide are the Jinja template and the LaTeX template.</p>"},{"location":"sciquill/biosketch/#4-jinja-template","title":"4. Jinja template","text":"<p>I use a jinja template to structure the above information into a biosketch. I've made my jinja template available here: databio.org/mm_templates/biosketch/nih_biosketch.jinja</p>"},{"location":"sciquill/biosketch/#5-latex-template","title":"5. LaTeX template","text":"<p>I included a LaTeX template for the NIH biosketch layout in this repository (https://github.com/databio/sciquill/blob/master/tex_templates/nih_bs.tex).</p>"},{"location":"sciquill/biosketch/#5-markmeld-configuration","title":"5. Markmeld configuration","text":"<p>Then, you just need a <code>_markmeld.yaml</code> file that configures this target by specifying the paths to each of the entities above. You can find an example in the repository above.</p>"},{"location":"sciquill/biosketch/#mix-and-match-contributions-and-statements","title":"Mix and match contributions and statements","text":"<p>One thing I like about this approach is that I can create new biosketches by mix-and-matching components, and I just have to create a new target in my <code>_markmeld.yaml</code> file. Then I don't have to keep a bunch of different versions up-to-date, because if I change something in the structured yaml bio data file (like a new academic position), it updates everything automatically because the biosketches are built on-the-fly.</p>"},{"location":"sciquill/biosketch/#future-plans","title":"Future plans","text":"<p>This <code>jinja</code> template, like any jinja template, expects the data in a certain structure; for example, the references need to be in an array under a key named <code>references</code>, the personal information is an object under <code>personal</code>, etc. I need to write a schema that defines these expectations, and then a little validator could tell you what you're missing, making it easier to get started.</p>"},{"location":"sciquill/change_marker/","title":"Marking changes","text":"<p>Sometimes we need to provide a version of a manuscript with changes marked. To make this easier, you can use the sciquill change marker filter. </p> <p>Turn on change marking by adding this to your document metadata:</p> <pre><code>mark_changes: true\n</code></pre> <p>Then, identify changes by using the <code>{.changed}</code> attribute to a text span, like this:</p> <p>This text will not be marked. [This text was changed.]{.changed} This text was not changed and will not be marked.</p> <p>You can then turn change marking on or off by just toggling the <code>mark_changes</code> setting, so you can just have a single source and build it with changes marked, and then without changes marked.</p> <p>The default text mark color is <code>brickred</code> but you can change the color in the metadata:</p> <pre><code>change_color: blue\n</code></pre>"},{"location":"sciquill/changelog/","title":"Changelog","text":""},{"location":"sciquill/changelog/#010-unreleased","title":"[0.1.0] -- Unreleased","text":""},{"location":"sciquill/changelog/#legacy","title":"Legacy","text":"<p>Sciquill was developed as 'mediabuilder' from 2017-2020 with various releases.</p>"},{"location":"sciquill/configure/","title":"Configuring sciquill","text":"<p>In sciquill, documents (or collections of related documents) are organized as repositories. Sciquill is configured in a <code>Makefile</code> placed in your repository's root.</p>"},{"location":"sciquill/configure/#1-link-your-makefile-to-sciquill","title":"1. Link your Makefile to sciquill","text":"<p>The first step is to include a sciquill Makefile as the first line in your Makefile. Here's a basic example:</p> <pre><code>include ${SQDIR}/makefiles/manuscript.make # Sciquill link\n</code></pre> <p>Here, we're using environment variable <code>${SQDIR}</code> for convenience, but you can also just point to it directly. If you set up this environment variable it will work with GitHub Actions.</p> <p>There are various media types available for you to use, each with its own Makefile. For instance, to get the <code>grant</code> targets, you'd do:</p> <pre><code>include ${SQDIR}/makefiles/grant.make # Sciquill link\n</code></pre> <p>Now, you should be able to build all the targets provided by sciquill for that media type.</p>"},{"location":"sciquill/configure/#2-configure-your-build","title":"2. Configure your build","text":"<p>You can change default behavior by adding in any of these options to your makefile:</p> <ul> <li><code>bib</code>: path to your bibtex file (use this to override the default, which uses <code>output/refs.bib</code> first, or if not found, then tries <code>$BIBTEXDB</code>).</li> <li><code>csl</code>:  style file</li> <li><code>lettertemplate</code>: template for letter</li> <li><code>textemplate</code>: LaTeX template</li> <li><code>manuscript_token</code>:  a string identifying which source file identifies your supplement source markdown file. Defaults to <code>manuscript</code></li> <li><code>supplement_token</code>: a string identifying which source file identifies your supplement source markdown file. Defaults to <code>supplement</code>.</li> </ul> <p>Foe example, here, we will set the <code>textemplate</code> and <code>csl</code> variables:</p> <pre><code>include ${SQDIR}/makefiles/grant.make # Sciquill link\n\ntextemplate=$(sqdir)/tex_templates/shefflab.tex\ncsl=$(sqdir)/csl/bioinformatics.csl\n</code></pre> <p>When setting these config options, you should use <code>$(sqdir)/</code> to refer to the sciquill repository. It will be provided for you automatically from your <code>include</code> instruction that links to the sciquill Makefile for your preferred media type.</p>"},{"location":"sciquill/configure/#configuring-targets","title":"Configuring targets","text":"<p>Each sciquill media type comes with one or more targets, which are items to build. For example, for a <code>manuscript</code> type, you can use <code>make manuscript</code> or a <code>make cover_letter</code>, or <code>make response</code> or <code>make manuscript_supplement</code>. There are also other targets, like <code>figs</code>, which creates all the figures. To explore in more detail, you can just look at the Makefile in the sciquill repository that provides the targets.</p>"},{"location":"sciquill/configure/#default-target","title":"Default target","text":"<p>When you type <code>make</code> without any parameters, you'll build the default target. GitHub Actions will build the default target. The built-in media types have sensible default targets. </p> <p>You can configure this by changing the default target in your <code>Makefile</code>:</p> <pre><code>.DEFAULT_GOAL := default\n</code></pre> <p>What if you want GitHub to build 2 different targets? You can also set the default target to build two targets by making a new target that depends on two other targets:</p> <pre><code>.DEFAULT_GOAL := twotargets\n\ntwotargets: manuscript cover_letter\n</code></pre>"},{"location":"sciquill/configure/#changing-targets","title":"Changing targets","text":"<p>To build a different target, for local computing just type <code>make target</code>. If using a github action, you can use the workflow_dispatch event trigger. Just click on \"Actions\" and select the Sciquill action; when you trigger the manual submission with \"Run workflow\", you can there specify a target manually.</p>"},{"location":"sciquill/cv/","title":"Curriculum Vitae","text":"<p>These examples are still under construction. You can build all these media types now, I just haven't had time to put together standalone demos. Feel free to contact me if you have specific questions. </p>"},{"location":"sciquill/figczar/","title":"Figures in sciquill","text":"<p>For figures, sciquill includes a pandoc filter called <code>figczar</code>, which adds power to pandoc's ability to display figures in LaTeX documents. I called it figczar because it handles several different underlying figure capabilities all in one filter. It can handle figures wrapping or setting multi-column figures.</p>"},{"location":"sciquill/figczar/#figure-labels","title":"Figure labels","text":"<p>You can refer to figures by LaTeX label instead of by number, which makes reordering figures within documents easy.  It also makes it possible to move figures and references from one document to another without renumbering. <pre><code>![\\label{abstract}Fig. \\ref{abstract}: Example figure](fig/example_figure.png) \n</code></pre></p> <p>Refer to figures with <code>\\ref{label}</code>.</p>"},{"location":"sciquill/figczar/#wrapfig","title":"Wrapfig","text":"<p>Append <code>{wrap=X}</code> as an attribute after your figure to wrap figures using the LaTeX wrapfig package. </p> <p>Use like this:</p> <pre><code>![\\label{myfigure}Fig \\ref{myfigure}. Fig Title](fig/pdf/figure.pdf){wrap=82mm}\n</code></pre> <p>Specify the width (i.e. 82mm) in any LaTeX-compatible way that suits you.</p>"},{"location":"sciquill/figczar/#full-width-figs","title":"Full-width figs","text":"<p>Use <code>{fullwidth=t}</code> as an image attribute to indicate a <code>\\figure*</code> (figure STAR) environment to make a figure span columns in a multi-column template.</p> <p>Use it like this:</p> <pre><code>![\\label{myfigure2}Fig \\ref{myfigure2}. Fig 2 Title](fig/pdf/figure2.pdf){fullwidth=t}\n</code></pre> <p>You can use any LaTeX-compatible positioning options here. For example, <code>{fullwidth=t}</code> sets valign to top, while <code>{fullwidth=b}</code> sets valign to bottom.</p> <p>Latex options summary:</p> <ul> <li>h: here. Place figure where the figure environment is, if there is enough room</li> <li>t: top. Place at the top of a page.</li> <li>b: bottom. Place at the bottom of a page.</li> <li>p: page. Place on a page containing only floats.</li> <li>!: bang/force. Ignore parameters for float placement.</li> </ul>"},{"location":"sciquill/github_actions/","title":"Automating a build with GitHub Action","text":""},{"location":"sciquill/github_actions/#getting-started","title":"Getting started","text":"<ol> <li> <p>Fork the example paper repository: https://github.com/databio/sciquill_paper_example</p> </li> <li> <p>Edit the file in <code>src/manuscript.md</code>.</p> </li> <li> <p>Wait for the GitHub Action to complete. You can watch progress by clicking on the Actions tab.</p> </li> <li> <p>View your PDF output in <code>output/manuscript.PDF</code>.</p> </li> </ol>"},{"location":"sciquill/github_actions/#configuring-your-own","title":"Configuring your own","text":"<p>If you want GitHub to automatically build your sciquill document when you make changes, then you can copy the <code>github_workflows/build-sciquill.yaml</code> file into your repository under <code>.github/workflows</code>.</p>"},{"location":"sciquill/install/","title":"Installing sciquill","text":""},{"location":"sciquill/install/#install-software-prerequisites","title":"Install software prerequisites","text":"<p>Sciquill is not one piece of software, but a collection of templates, recipes, and scripts. These scripts and templates require several open source tools, such as <code>pandoc</code> and <code>inkscape</code>. Because sciquill handles the whole stack of creating documents, including authoring in markdown, figure layouts and generation, and building PDFs, there are a few prerequisites.</p>"},{"location":"sciquill/install/#remote-building-with-github-actions","title":"Remote building with GitHub Actions","text":"<p>Sciquill can be easily set up to use github actions to build your documents in the cloud. You just edit markdown source files in your git repository, and then the output PDFs are built automatically via a github action. To use sciquill in this way, you don't need to install anything; just set up the sciquill github action. If you want to build things locally, then you can follow one of the approaches below. </p>"},{"location":"sciquill/install/#local-building-option-1-use-bulker","title":"Local building option 1: Use bulker","text":"<p>The easiest way to get everything you need is to just use bulker, which is a container manager built on docker or singularity. If you have bulker already configured, then setting up sciquill is simple:</p> <pre><code>pip install bulker\nbulker load databio/sciquill\nbulker activate databio/sciquill\n</code></pre> <p>You will also need to add the sciquill environment variables to your bulker config file:</p> <pre><code>bulker envvars -a TEXINPUTS\nbulker envvars -a SQDIR\nbulker envvars -a BIBTEXDB\n</code></pre> <p>That alone will set up all the prerequisites you need to run sciquill.</p>"},{"location":"sciquill/install/#local-building-option-2-install-everything-natively","title":"Local building option 2: Install everything natively","text":"<p>If you don't want to use bulker, the other option is to install everything natively.</p> <ul> <li>Install pandoc to convert markdown to PDF.</li> <li>Install inkscape to convert SVG to PDF.</li> <li>Install libreoffice (optional) for some recipes that read <code>xls</code> or <code>docx</code> files.</li> <li>Install ghostscript (optional) if you need to merge PDFs (should be standard on linux).</li> </ul>"},{"location":"sciquill/install/#configuring-sciquill","title":"Configuring sciquill","text":"<p>After all the necessary is software is installed, you need to get the sciquill scripts and templates.</p> <ul> <li>Clone databio/sciquill</li> <li>Configure <code>sciquill</code>. The examples use an environment variable <code>$SQDIR</code> to point to this repository:</li> </ul> <pre><code>git clone git@github.com:databio/sciquill.git\nexport SQDIR=`pwd`/sciquill\n</code></pre> <p>You'll want to add <code>export SQDIR=/path/to/sqdir</code> to your <code>.bashrc</code> so it will persist.</p> <p>The latex templates in <code>tex_templates</code> rely on some relative includes. To use these, you'll need to add the path to that folder to your <code>TEXINPUTS</code> environment variable. Adding something like this in your <code>.bashrc</code> will accomplish this permanently (use your local path):</p> <pre><code>export TEXINPUTS=\"${TEXINPUTS}${SQDIR}/tex_templates/:\"\n</code></pre>"},{"location":"sciquill/install/#assemble-your-bibtex-database-optional","title":"Assemble your BibTeX database (optional).","text":"<p>If you want to produce a media type that includes citations, you will also need a <code>bibtex</code> file with your references. My favorite BibTeX management software is JabRef, because it is free, actively developed, and uses BibTeX as its native file format. The default makefile (sciquill.make) will use an <code>${BIBTEXDB}</code> environment variable to look for your <code>bibtex</code> database. You can set it like this:</p> <pre><code>export BIBTEXDB=path/to/db.bib\n</code></pre> <p>As usual, make sure to put this in your <code>.bashrc</code> if you want it to persist.</p>"},{"location":"sciquill/letter/","title":"Letter","text":"<p>These examples are still under construction. You can build all these media types now, I just haven't had time to put together standalone demos. Feel free to contact me if you have specific questions. </p>"},{"location":"sciquill/mail_merge/","title":"Mail merge","text":"<p>Mail merges are now possible using what are called markmeld \"multi-output\" targets. Basically, you need to specify 2 things: 1) a variable with an array to loop over, and 2) a variable name that will assume the value of each item in the array. For a mail merge, your array would be a list of addressees, and you'd assign each one to some variable, say, <code>recipient</code>. Then, you just have to ensure that your jinja template uses the <code>recipient</code> variable, and specify an output filepath that uses something that varies in the <code>recipient</code> variable, and that's it.</p> <p>This process is documented here: </p> <p>https://github.com/databio/markmeld/blob/master/docs/multi_targets.md</p> <p>See this issue for more information: https://github.com/databio/markmeld/issues/1.</p>"},{"location":"sciquill/manuscript/","title":"Building a manuscript with sciquill","text":""},{"location":"sciquill/manuscript/#examples-of-inputoutput","title":"Examples of input/output","text":"<p>I use markmeld to produce all our lab's preprints. I've made some jinja templates available here:</p> <p>https://github.com/databio/mm_templates/tree/master/manuscript</p> <p>There are few example repositories showing how this works:</p> <p>The markmeld repository contains a demo.</p> <p>There's also a standalone demo here that also shows you how to use a github action to build the manuscript:</p> <p>https://github.com/databio/sciquill_paper_example</p> <p>I still need to work on a full demo for how to build it on your own, which I plan to put in the examples folder in this repository.</p>"},{"location":"sciquill/multi_refs/","title":"Multi-refs","text":"<p>If you want to use pandoc with multiple references sections, <code>multi-refs</code> is a lua filter for you.</p> <p>I documented this here: https://github.com/databio/sciquill/tree/master/pandoc_filters/multi-refs</p> <p>Also check out this blog post: Handling supplemental citations with pandoc</p>"},{"location":"sciquill/nih_r01/","title":"NIH grant","text":"<p>These examples are still under construction. You can build all these media types now, I just haven't had time to put together standalone demos. Feel free to contact me if you have specific questions. </p>"},{"location":"sciquill/recipes/","title":"Sciquill recipes","text":"<p>Sciquill build instructions are just shell scripts stored in a makefile. Here are some useful recipes I've created over the years that you can add to your makefile:</p>"},{"location":"sciquill/recipes/#converting-an-xls-file-to-pdf-with-libreoffice","title":"Converting an <code>.xls</code> file to <code>.pdf</code> with <code>libreoffice</code>:","text":"<p>Running <code>libreoffice</code> on the command-line like this will silently fail if you already have <code>libreoffice</code> running. If you use a containerized version, you can get around that issue. Use my <code>libre</code> docker container so you can run it while the real one is open. Or, this problem is also solved by using bulker.</p> <pre><code>budget:\n    echo \"Make sure libreoffice isn't already open\"\n    libreoffice --headless --invisible --convert-to pdf \\\n    --outdir output \\\n    src/budget_worksheet.xlsx\n</code></pre> <p>To set page printing limits in libreoffice calc: - go to View &gt; Page Break - now select the area to print - choose: Format &gt; Print Ranges &gt; Define</p>"},{"location":"sciquill/recipes/#converting-a-docx-to-pdf-with-libreoffice","title":"Converting a <code>.docx</code> to <code>.pdf</code> with  <code>libreoffice</code>:","text":"<pre><code>pdf:\n    soffice --convert-to pdf output/toc.docx \\\n    --outdir output\n</code></pre>"},{"location":"sciquill/recipes/#merging-pdfs-with-ghostscript","title":"Merging PDFs with <code>ghostscript</code>:","text":"<pre><code>merge:\n    $(mbin)/mergepdf output/merged.pdf \\\n    output/title_page.pdf \\\n    output/research_proposal.pdf \\\n    output/assembly_plan.pdf\n</code></pre>"},{"location":"sciquill/recipes/#adding-page-numbers","title":"Adding page numbers","text":"<p>To add page numbers:</p> <ol> <li>put the PDF document into the <code>tex_utilities/addpages.tex</code> file.</li> <li>Run: <code>pdflatex addpages.tex</code></li> <li>Page numbers are added at addpages.pdf!</li> </ol>"},{"location":"sciquill/simple_grant/","title":"Simple grant","text":"<p>These examples are still under construction. You can build all these media types now, I just haven't had time to put together standalone demos. Feel free to contact me if you have specific questions. </p>"}]}